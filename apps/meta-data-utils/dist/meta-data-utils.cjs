"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const Y=()=>["BOOL","BOOL_ARRAY","DATE","DATE_ARRAY","DATETIME","AUTO_ID","DATETIME_ARRAY","DECIMAL","DECIMAL_ARRAY","EMAIL","EMAIL_ARRAY","FILE","HEADING","HYPERLINK","HYPERLINK_ARRAY","INT","INT_ARRAY","LONG","LONG_ARRAY","ONTOLOGY","ONTOLOGY_ARRAY","REF","REF_ARRAY","REFBACK","STRING","STRING_ARRAY","TEXT","TEXT_ARRAY","UUID","UUID_ARRAY"],N=e=>{for(const r in e)if(Object.hasOwnProperty.call(e,r))return!1;return!0},A=e=>e.columnType==="STRING"||e.columnType==="TEXT"||e.columnType==="EMAIL"||e.columnType==="HYPERLINK"||e.columnType==="UUID"||e.columnType==="DATE"||e.columnType==="DATETIME"||e.columnType==="INT"||e.columnType==="LONG"||e.columnType==="DECIMAL",F=e=>e.columnType==="REF"||e.columnType==="REFBACK"||e.columnType==="ONTOLOGY",O=e=>e.columnType.endsWith("_ARRAY"),b=e=>e.columnType==="FILE",E="{ id, size, extension, url }",w=(e,r,t)=>{const a=e[r].tables.find(o=>o.id===t),y=a==null?void 0:a.columns,d=y==null?void 0:y.filter(o=>!o.id.startsWith("mg_")).filter(o=>o.columnType!=="HEADING"),s=o=>{const R=e[o.refSchemaId||r].tables.find(l=>l.id===o.refTableId),u=R==null?void 0:R.columns,f=u==null?void 0:u.filter(l=>!l.id.startsWith("mg_")).filter(l=>l.columnType!=="HEADING"),p=f==null?void 0:f.map(l=>{switch(l.columnType){case"STRING":case"TEXT":return l.id;case"FILE":return`${l.id} ${E}`;case"REF":case"ONTOLOGY":case"REF_ARRAY":case"REFBACK":case"ONTOLOGY_ARRAY":return"";default:return l.id}});return p?p.join(" "):""},i=d==null?void 0:d.map(o=>{switch(o.columnType){case"STRING":case"TEXT":return o.id;case"FILE":return`${o.id} ${E}`;case"REF":case"ONTOLOGY":case"REF_ARRAY":case"REFBACK":case"ONTOLOGY_ARRAY":return`${o.id} { ${s(o)} }`;default:return o.id}});return i?i.join(" "):""},M=(e,r,t)=>{const n=I(e,r,t),a=c(t[r],e);if(a===void 0)throw new Error("buildRecordListQueryFields; tableMetaData is undefined for tableId "+e+" in schema "+r);const y=a.columns.map(T=>T.id),d=["id","label","description","pid","acronym","logo"].filter(T=>y.includes(T));d[d.length-1]==="logo"&&d.push(["id","size","extension","url"]);const s=[...new Set([...n,...d])];return D(s)},D=e=>e.reduce((r,t)=>Array.isArray(t)?r+=" { "+D(t)+" } ":r+=" "+t,""),I=(e,r,t)=>{const n=t[r];return c(n,e).columns.reduce((d,s)=>{if(s.key===1)if(A(s))d.push(s.id);else if(F(s))if(s.refTableId)d.push(s.id),d.push(I(s.refTableId,s.refSchemaId||r,t));else throw new Error("refTable is undefined for refColumn with id "+s.id+" in table "+e);else O(s)?console.log("TODO: buildRecordListQueryFields, key column isArrayType, skip for now"):b(s)?console.log("TODO: buildRecordListQueryFields, key column isFileType, skip for now"):console.log("TODO: buildRecordListQueryFields, key column is unknown type, skip for now");return d},[])||[]},h=e=>[...new Set(e.tables.reduce((r,t)=>(t.columns.forEach(n=>{n.refSchemaId&&r.push(n.refSchemaId)}),r),[]))],L=(e,r,t,n)=>{const a=n[t];return c(a,r).columns.reduce((s,i)=>{if(i.key===1&&e[i.id])if(A(i))s[i.id]=e[i.id];else if(F(i))if(i.refTableId)s[i.id]=L(e[i.id],i.refTableId,i.refSchemaId||t,n);else throw new Error("refTable is undefined for refColumn with id "+i.id+" in table "+r);else O(i)?console.log("TODO: extractKeyFromRecord, key column isArrayType, skip for now"):b(i)?console.log("TODO: extractKeyFromRecord, key column isFileType, skip for now"):console.log("TODO: extractKeyFromRecord, key column is unknown type, skip for now");return s},{})||{}},_=e=>Object.entries(e).reduce((r,[t,n])=>(r[t]={equals:[n]},r),{}),c=(e,r)=>{const t=e.tables.find(n=>n.id===r);if(t===void 0){const n="ERROR: tableMetaData is undefined for tableId "+r;throw console.log(n),new Error(n)}return t},k=e=>`Hello ${e}`;exports.buildFilterFromKeysObject=_;exports.buildRecordDetailsQueryFields=w;exports.buildRecordListQueryFields=M;exports.extractExternalSchemas=h;exports.extractKeyFromRecord=L;exports.fieldTypes=Y;exports.getTableMetaData=c;exports.isEmpty=N;exports.isValueType=A;exports.sayHello=k;
